

(defun reload () (load "sudoku_main.lsp"))

; sudoku map : (3x3x3x3) -> notation (x,y)*(x',y') s.t. \forall x,y,x',y' \in S s.t. S = {w|0<=w<=2}

; takes board(2d plane): 4D array (3x3x3x3)
;				try(point): (x,y,z,w,n) -> (y,x)*(w,z) = n -> (aref y x w z)
;				misc(list): contains general info includes
;										(# of failed_ans, # of turn, list of answer)
;										(list of answer - stack of point(x,y,z,f)
(defun solve (board ans misc)
	(cond ((not (null (aref board (second ans) (first ans) (fourth ans) (third ans)))) (failed_solve board misc))
				((is_wrong_horizontal_num board ans) (failed_solve board misc))
				((is_wrong_vertical_num board ans) (failed_solve board misc))
				((is_wrong_square_num board ans) (failed_solve board misc))
				(T (passed_solve board ans misc))
				)
	)

(defun is_wrong_horizontal_num (board ans)
	(let* ((y (second ans))
				 (w (fourth ans))
				 (n (fifth ans))
				 )
		(labels ((inner (x z)
										(cond ((> z 2) NIL)
													((eql (aref board y x w z) n) T)
													(T (inner x (+ z 1)))
													)
										)
						 (outer (x)
										(cond ((> x 2) NIL)
													((inner x 0) T)
													(T (outer (+ x 1)))
													)
										)
						 )
			(outer 0)
			)
		)
	)

(defun is_wrong_vertical_num (board ans)
	(let* ((x (first ans))
				 (z (third ans))
				 (n (fifth ans))
				 )
		(labels ((inner (y w)
										(cond ((> w 2) NIL)
													((eql (aref board y x w z) n) T)
													(T (inner y (+ w 1)))
													)
										)
						 (outer (y)
										(cond ((> y 2) NIL)
													((inner y 0) T)
													(T (outer (+ y 1)))
													)
										)
						 )
			(outer 0)
			)
		)
	)

(defun is_wrong_square_num (board ans)
	(let* ((x (first ans))
				 (y (second ans))
				 (n (fifth ans))
				 )
		(labels ((inner (w z)
										(cond ((> z 2) NIL)
													((eql (aref board y x w z) n) T)
													(T (inner w (+ z 1)))
													)
										)
						 (outer (w)
										(cond ((> w 2) NIL)
													((inner w 0) T)
													(T (outer (+ w 1)))
													)
										)
						 )
			(outer 0)
			)
		)
	)

(defun failed_solve (board misc)
	(let ((failed_ans (first misc))
				(turn (second misc))
				(ansList (third misc))
				)
		(board '((+ failed_ans 1) (+ turn 1) ansList))
		)
	)

(defun passed_solve (board ans misc)
	(let ((x (first ans))
				(y (second ans))
				(z (third ans))
				(w (fourth ans))
				(n (fifth ans))
				(failed_ans (first misc))
				(turn (second misc))
				(ansList (third misc))
				)
		(setf (aref board y x w z) n)
		(list  board (list failed_ans (+ turn 1) (append ansList (list ans))))
		)
	)

;|(0,0)|(0,1)|(0,2)| (y,x), (w,z)
;|(1,0)|(1,1)|(1,2)|
;|(2,0)|(2,1)|(2,2)|

;display

(defun draw_x (board)
	(loop for x from 0 to 2 do
				(

(defun draw_sudoku (board)
	(do(cur board)
		(format t "|")
		(if (null cur) (format t " ") (prin1 cur))
		)
	)

(setf test1 (make-array '(3 3 3 3) :initial-contents
												'((((NIL 5 NIL) (NIL NIL NIL) (NIL 2 NIL))
													 ((1 2 NIL) (NIL 3 NIL) (8 NIL NIL))
													 ((8 6 9) (NIL 7 NIL) (4 NIL 5)))
													(((5 NIL NIL) (NIL NIL NIL) (8 NIL NIL))
													 ((NIL 8 2) (9 NIL 1) (6 5 NIL))
													 ((NIL NIL 1) (NIL NIL NIL) (NIL NIL 4)))
													(((7 NIL 8) (NIL 6 NIL) (3 1 9))
													 ((NIL NIL 6) (NIL 1 NIL) (NIL 7 5))
													 ((NIL 1 NIL) (NIL NIL NIL) (NIL 8 NIL))))
												)
			)
